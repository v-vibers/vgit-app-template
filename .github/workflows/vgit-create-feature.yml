name: VGit Create Feature
on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Name for the new branch"
        required: true
        type: string
      request:
        description: "Feature request description"
        required: true
        type: string
      username:
        description: "GitHub username"
        required: true
        type: string
      current_node:
        description: "Current workspace node (optional)"
        required: false
        type: string
      base_branch:
        description: "Base branch to create feature from"
        required: false
        type: string
        default: "main"
      environment:
        description: "GitHub environment to use for deployment"
        required: false
        type: string
      runtime_vars:
        description: "Comma-separated list of env var names to expose at runtime"
        required: false
        type: string
        default: ""

jobs:
  create-feature:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ github.event.inputs.environment || '' }}
    permissions:
      contents: write # For git operations (checkout, commit, push)
      actions: read # For workflow operations

    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.branch_name }}" ]; then
            echo "‚ùå Branch name is required"
            exit 1
          fi
          if [ -z "${{ github.event.inputs.request }}" ]; then
            echo "‚ùå Feature request is required"
            exit 1
          fi
          echo "‚úÖ Inputs validated"
          echo "Branch: ${{ github.event.inputs.branch_name }}"
          echo "Request: ${{ github.event.inputs.request }}"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "${{ github.event.inputs.username }}"
          git config --global user.email "${{ github.event.inputs.username }}@users.noreply.github.com"

      - name: Create feature branch
        run: |
          echo "üåø Creating feature branch: ${{ github.event.inputs.branch_name }}"

          # Ensure we're on the base branch
          git checkout ${{ github.event.inputs.base_branch }}
          git pull origin ${{ github.event.inputs.base_branch }}

          # Create and switch to feature branch
          git checkout -b "${{ github.event.inputs.branch_name }}"

          echo "‚úÖ Feature branch created successfully"
      - name: Update commit with pending preview info
        run: |
          echo "üìù Starting feature request"

          # Amend commit with preview information
          UPDATED_COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ü§ñ Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          ---PREVIEW-INFO---
          Preview URL: still_pending
          Screenshot URL: still_pending
          "

          git commit --amend -m "$UPDATED_COMMIT_MSG"
          git push origin "${{ github.event.inputs.branch_name }}" --force-with-lease
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: |
          if [ -f "package.json" ]; then
            echo "üì¶ Installing dependencies..."
            npm install
          else
            echo "‚ö†Ô∏è No package.json found, skipping dependency installation"
          fi

      - name: Export all secrets as environment variables dynamically
        run: |
          echo "üîê Dynamically exporting all secrets as environment variables..."
          if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
            echo "üìã Processing secrets from environment..."
            echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' >> $GITHUB_ENV
            echo "‚úÖ All secrets exported as environment variables"
          else
            echo "‚ÑπÔ∏è No secrets found in environment"
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Prepare runtime environment variables
        run: |
          echo "üîß Preparing runtime environment variables..."

          # Debug: Show which environment variables are available (names only, not values)
          echo "üîç Available environment variables (for debugging):"
          env | grep -E '^(ANTHROPIC|SUBSCRIBE|OPENAI|CUSTOM)' | cut -d'=' -f1 | sort || echo "No addon-related environment variables found"

          # Parse runtime_vars input (comma-separated list)
          RUNTIME_VARS="${{ github.event.inputs.runtime_vars }}"

          if [ -n "$RUNTIME_VARS" ] && [ "$RUNTIME_VARS" != "" ]; then
            echo "üìã Runtime variables to expose: $RUNTIME_VARS"
            
            # Create a script to export VITE_ prefixed versions
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "# Auto-generated runtime environment variables" >> runtime_env_setup.sh
            
            # Split comma-separated values and create VITE_ versions
            IFS=',' read -ra VARS <<< "$RUNTIME_VARS"
            for var in "${VARS[@]}"; do
              # Trim whitespace
              var=$(echo "$var" | xargs)
              
              if [ -n "$var" ]; then
                # Convert to uppercase
                upper_var=$(echo "$var" | tr '[:lower:]' '[:upper:]')
                vite_var="VITE_$upper_var"
                
                echo "Creating runtime variable: $upper_var -> $vite_var"
                
                # Add export statement to script
                echo "if [ -n \"\${$upper_var}\" ]; then" >> runtime_env_setup.sh
                echo "  export $vite_var=\"\${$upper_var}\"" >> runtime_env_setup.sh
                echo "  echo \"‚úÖ Exposed $upper_var as $vite_var\"" >> runtime_env_setup.sh
                echo "else" >> runtime_env_setup.sh
                echo "  echo \"‚ö†Ô∏è $upper_var not found in environment\"" >> runtime_env_setup.sh
                echo "fi" >> runtime_env_setup.sh
              fi
            done
            
            # Make the script executable
            chmod +x runtime_env_setup.sh
            
            echo "üîç Runtime environment setup script created:"
            cat runtime_env_setup.sh
          else
            echo "‚ÑπÔ∏è No runtime variables specified, skipping VITE_ prefix setup"
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "echo 'No runtime variables to expose'" >> runtime_env_setup.sh
            chmod +x runtime_env_setup.sh
          fi

      - name: Install Anthropic SDK
        run: |
          echo "üì¶ Installing Anthropic SDK and TypeScript tools..."
          npm install @anthropic-ai/sdk@latest tsx @types/node
          echo "‚úÖ Anthropic SDK installed"

      - name: Check for CLAUDE.md
        run: |
          echo "üìÑ Checking for CLAUDE.md project instructions..."
          if [ -f "CLAUDE.md" ]; then
            echo "‚úÖ Found CLAUDE.md - Claude Code will use project-specific instructions"
            wc -l CLAUDE.md | awk '{print "  Lines:", $1}'
          else
            echo "‚ÑπÔ∏è No CLAUDE.md found - using generic instructions"
          fi

      - name: Implement feature with Anthropic SDK
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          if [ -z "$ANTHROPIC_API_KEY" ]; then
            echo "‚ùå ANTHROPIC_API_KEY is required"
            exit 1
          fi

          echo "ü§ñ Running Anthropic SDK to implement feature..."

          # Create the feature implementation script
          cat > implement_feature.ts << 'TYPESCRIPT_EOF'
import fs from 'node:fs';
import path from 'node:path';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import Anthropic from '@anthropic-ai/sdk';

const execAsync = promisify(exec);

// Logging system
interface LogEntry {
  timestamp: string;
  type: 'system' | 'tool' | 'message' | 'error';
  content: string;
  metadata?: any;
}

const logs: LogEntry[] = [];

function log(type: LogEntry['type'], content: string, metadata?: any) {
  const entry: LogEntry = {
    timestamp: new Date().toISOString(),
    type,
    content,
    metadata
  };
  logs.push(entry);

  const prefix = type === 'error' ? '‚ùå' : type === 'tool' ? 'üîß' : type === 'message' ? 'üí¨' : 'üìù';
  console.log(`${prefix} [${type.toUpperCase()}] ${content}`);
  if (metadata) console.log('   ', JSON.stringify(metadata, null, 2));

  // Append to log file immediately
  fs.appendFileSync('claude-execution.log', JSON.stringify(entry) + '\n');
}

// Tool implementations
class Tools {
  async read(filePath: string): Promise<string> {
    try {
      log('tool', `Reading file: ${filePath}`);
      const content = fs.readFileSync(filePath, 'utf8');
      log('tool', `Successfully read ${filePath} (${content.length} chars)`);
      return content;
    } catch (error) {
      const msg = `Failed to read ${filePath}: ${error}`;
      log('error', msg);
      return `Error: ${msg}`;
    }
  }

  async write(filePath: string, content: string): Promise<string> {
    try {
      log('tool', `Writing file: ${filePath}`, { contentLength: content.length });
      fs.mkdirSync(path.dirname(filePath), { recursive: true });
      fs.writeFileSync(filePath, content, 'utf8');
      log('tool', `Successfully wrote ${filePath}`);
      return `Successfully wrote ${filePath}`;
    } catch (error) {
      const msg = `Failed to write ${filePath}: ${error}`;
      log('error', msg);
      return `Error: ${msg}`;
    }
  }

  async edit(filePath: string, oldText: string, newText: string): Promise<string> {
    try {
      log('tool', `Editing file: ${filePath}`);
      const content = fs.readFileSync(filePath, 'utf8');

      if (!content.includes(oldText)) {
        const msg = `Old text not found in ${filePath}`;
        log('error', msg);
        return `Error: ${msg}`;
      }

      const newContent = content.replace(oldText, newText);
      fs.writeFileSync(filePath, newContent, 'utf8');
      log('tool', `Successfully edited ${filePath}`);
      return `Successfully edited ${filePath}`;
    } catch (error) {
      const msg = `Failed to edit ${filePath}: ${error}`;
      log('error', msg);
      return `Error: ${msg}`;
    }
  }

  async bash(command: string): Promise<string> {
    try {
      log('tool', `Executing bash: ${command}`);
      const { stdout, stderr } = await execAsync(command, { maxBuffer: 10 * 1024 * 1024 });
      const output = stdout + stderr;
      log('tool', `Bash completed`, { command, outputLength: output.length });
      return output || 'Command executed successfully';
    } catch (error: any) {
      const msg = `Bash command failed: ${error.message}`;
      log('error', msg, { command });
      return `Error: ${msg}\nOutput: ${error.stdout || ''}\n${error.stderr || ''}`;
    }
  }

  async glob(pattern: string): Promise<string> {
    try {
      log('tool', `Glob pattern: ${pattern}`);
      const { stdout } = await execAsync(`find . -path '${pattern}' -type f 2>/dev/null | head -100`);
      const files = stdout.trim().split('\n').filter(Boolean);
      log('tool', `Found ${files.length} files matching ${pattern}`);
      return files.join('\n');
    } catch (error) {
      const msg = `Glob failed: ${error}`;
      log('error', msg);
      return `Error: ${msg}`;
    }
  }
}

// Main implementation
async function implementFeature() {
  try {
    log('system', 'Starting feature implementation');

    const client = new Anthropic({ apiKey: process.env.ANTHROPIC_API_KEY! });
    const tools = new Tools();
    const FEATURE_REQUEST = process.env.FEATURE_REQUEST || '';

    if (!FEATURE_REQUEST) {
      log('error', 'No FEATURE_REQUEST provided');
      process.exit(1);
    }

    log('system', `Feature request: ${FEATURE_REQUEST}`);

    // Read CLAUDE.md if it exists
    let claudeMd = '';
    try {
      claudeMd = await tools.read('CLAUDE.md');
      log('system', 'Found and read CLAUDE.md');
    } catch {
      log('system', 'No CLAUDE.md found');
    }

    // Build comprehensive prompt
    const systemPrompt = `You are an expert software engineer implementing features in this repository.

You have access to these tools:
- read(path): Read a file
- write(path, content): Write/create a file
- edit(path, old_text, new_text): Replace text in a file
- bash(command): Run bash commands (use for git, npm, etc)
- glob(pattern): Find files matching a pattern

${claudeMd ? `\n## Project Instructions (CLAUDE.md)\n${claudeMd}\n` : ''}

## Important Guidelines
- ALWAYS read CLAUDE.md first if it exists
- Follow ALL project conventions from CLAUDE.md
- Assume environment variables are always available
- Write production-ready, fully functional code
- Match existing code style and patterns
- Make focused, minimal changes
- For UI: follow existing styling approach, ensure responsive design, add proper loading/error states
- Subscribe.dev: ONLY use if explicitly mentioned in request (phrases: "with subscribe.dev", "using subscribe.dev", etc)

You MUST use the provided tools to make changes. Do not just describe what to do - actually use the tools to implement the feature.`;

    const userPrompt = `Implement this feature: ${FEATURE_REQUEST}

Repository: ${process.env.GITHUB_REPOSITORY || 'unknown'}
Branch: ${process.env.BRANCH_NAME || 'unknown'}

Steps:
1. Read CLAUDE.md if you haven't already (use read tool)
2. Use glob/read to understand the codebase structure
3. Make the necessary changes using write/edit tools
4. Update package.json if adding dependencies (use edit tool)
5. Use bash tool for npm install if needed

Start implementing now using the tools.`;

    // Define tool schemas for Claude
    const toolDefinitions: Anthropic.Tool[] = [
      {
        name: 'read',
        description: 'Read the contents of a file',
        input_schema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'File path to read' }
          },
          required: ['path']
        }
      },
      {
        name: 'write',
        description: 'Write content to a file (creates directories if needed)',
        input_schema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'File path to write' },
            content: { type: 'string', description: 'Content to write' }
          },
          required: ['path', 'content']
        }
      },
      {
        name: 'edit',
        description: 'Edit a file by replacing old text with new text',
        input_schema: {
          type: 'object',
          properties: {
            path: { type: 'string', description: 'File path to edit' },
            old_text: { type: 'string', description: 'Text to replace' },
            new_text: { type: 'string', description: 'Replacement text' }
          },
          required: ['path', 'old_text', 'new_text']
        }
      },
      {
        name: 'bash',
        description: 'Execute a bash command',
        input_schema: {
          type: 'object',
          properties: {
            command: { type: 'string', description: 'Bash command to execute' }
          },
          required: ['command']
        }
      },
      {
        name: 'glob',
        description: 'Find files matching a glob pattern',
        input_schema: {
          type: 'object',
          properties: {
            pattern: { type: 'string', description: 'Glob pattern (e.g., "**/*.ts")' }
          },
          required: ['pattern']
        }
      }
    ];

    // Conversation loop
    const messages: Anthropic.MessageParam[] = [
      { role: 'user', content: userPrompt }
    ];

    let continueLoop = true;
    let iterationCount = 0;
    const MAX_ITERATIONS = 20;

    while (continueLoop && iterationCount < MAX_ITERATIONS) {
      iterationCount++;
      log('system', `Iteration ${iterationCount}/${MAX_ITERATIONS}`);

      const response = await client.messages.create({
        model: 'claude-sonnet-4-5-20250929',
        max_tokens: 4096,
        system: systemPrompt,
        messages,
        tools: toolDefinitions
      });

      log('message', `Claude response (stop_reason: ${response.stop_reason})`);

      // Process response content
      let hasToolUse = false;
      const toolResults: Anthropic.ToolResultBlockParam[] = [];

      for (const block of response.content) {
        if (block.type === 'text') {
          log('message', `Claude: ${block.text.substring(0, 200)}${block.text.length > 200 ? '...' : ''}`);
        } else if (block.type === 'tool_use') {
          hasToolUse = true;
          log('tool', `Tool call: ${block.name}`, block.input);

          let result: string;
          try {
            switch (block.name) {
              case 'read':
                result = await tools.read((block.input as any).path);
                break;
              case 'write':
                result = await tools.write((block.input as any).path, (block.input as any).content);
                break;
              case 'edit':
                result = await tools.edit((block.input as any).path, (block.input as any).old_text, (block.input as any).new_text);
                break;
              case 'bash':
                result = await tools.bash((block.input as any).command);
                break;
              case 'glob':
                result = await tools.glob((block.input as any).pattern);
                break;
              default:
                result = `Unknown tool: ${block.name}`;
            }
          } catch (error) {
            result = `Tool execution error: ${error}`;
            log('error', result);
          }

          toolResults.push({
            type: 'tool_result',
            tool_use_id: block.id,
            content: result
          });
        }
      }

      // Check if we should continue
      if (response.stop_reason === 'end_turn' || !hasToolUse) {
        continueLoop = false;
        log('system', 'Conversation ended');
      } else {
        // Add assistant message and tool results to conversation
        messages.push({
          role: 'assistant',
          content: response.content
        });

        if (toolResults.length > 0) {
          messages.push({
            role: 'user',
            content: toolResults
          });
        }
      }
    }

    if (iterationCount >= MAX_ITERATIONS) {
      log('system', 'Reached maximum iterations');
    }

    log('system', 'Feature implementation completed');

    // Save logs
    fs.writeFileSync('claude-execution.log.json', JSON.stringify({ logs, totalIterations: iterationCount }, null, 2));

    return 0;

  } catch (error: any) {
    log('error', `Fatal error: ${error.message}`, { stack: error.stack });

    // Save error summary
    const errorLogs = logs.filter(l => l.type === 'error');
    const errorSummary = errorLogs.map(l => l.content).join('\n');
    fs.writeFileSync('claude-error-summary.txt', errorSummary);

    // Save all logs
    fs.writeFileSync('claude-execution.log.json', JSON.stringify({ logs, error: error.message }, null, 2));

    return 1;
  }
}

// Run
implementFeature().then(code => {
  process.exit(code);
}).catch(error => {
  console.error('‚ùå Unhandled error:', error);
  process.exit(1);
});
TYPESCRIPT_EOF

          echo "üìã Running feature implementation with Anthropic SDK..."

          FEATURE_REQUEST='${{ github.event.inputs.request }}' \
          GITHUB_REPOSITORY='${{ github.repository }}' \
          BRANCH_NAME='${{ github.event.inputs.branch_name }}' \
          npx tsx implement_feature.ts || {
            echo "CLAUDE_EXECUTION_FAILED=true" >> $GITHUB_ENV
          }

          echo "‚úÖ Anthropic SDK execution completed"

      - name: Upload Claude execution logs as artifact
        if: always()  # Upload logs even if previous step failed
        uses: actions/upload-artifact@v4
        with:
          name: claude-execution-logs
          path: |
            claude-execution.log
            claude-execution.log.json
            claude-error-summary.txt
            implement_feature.ts
          retention-days: 7
          if-no-files-found: warn

      - name: Install new dependencies (if package.json changed)
        run: |
          cat package.json

          if git diff --name-only | grep -q "package.json"; then
            echo "üì¶ package.json was modified, installing new dependencies..."
            npm install
          else
            echo "‚ÑπÔ∏è No package.json changes detected"
          fi

      - name: Verify changes
        run: |
          echo "üîç Verifying implemented changes..."

          # Check if any files were modified
          if git diff --quiet; then
            echo "‚ö†Ô∏è No changes detected. Creating a minimal change to complete the workflow."
            echo "# Feature: ${{ github.event.inputs.request }}" >> FEATURE_LOG.md
            echo "- Implemented on: $(date)" >> FEATURE_LOG.md
            echo "- Branch: ${{ github.event.inputs.branch_name }}" >> FEATURE_LOG.md
            echo "" >> FEATURE_LOG.md
          else
            echo "‚úÖ Changes detected:"
            git diff --name-only
          fi

      - name: Run tests (if available)
        run: |
          echo "üß™ Running tests..."
          if [ -f "package.json" ] && grep -q '"test"' package.json; then
            npm test || {
              echo "‚ö†Ô∏è Tests failed, but continuing with feature implementation"
              echo "TEST_FAILURES=true" >> $GITHUB_ENV
            }
          else
            echo "‚ÑπÔ∏è No test script found, skipping tests"
          fi

      - name: Commit changes
        run: |
          echo "üìù Committing changes..."

          # Add all changes
          git add .

          # Check if Claude execution failed and include error logs
          if [ "$CLAUDE_EXECUTION_FAILED" = "true" ] && [ -f "claude-error-summary.txt" ]; then
            echo "‚ö†Ô∏è Claude execution failed, including error logs in commit message"

            # Read error summary (truncated to 500 chars)
            ERROR_SUMMARY=$(cat claude-error-summary.txt)

            COMMIT_MSG="feat: ${{ github.event.inputs.request }} [FAILED]

          ‚ùå Claude SDK execution failed

          ü§ñ Generated with VGit AI (Anthropic SDK)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          ---ERROR-LOG---
          ${ERROR_SUMMARY}

          Full logs available in GitHub Actions artifacts.

          Co-Authored-By: Claude Code <ai@vgit.app>"
          else
            # Standard commit message for successful execution
            COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ü§ñ Generated with VGit AI (Anthropic SDK)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          Co-Authored-By: Claude Code <ai@vgit.app>"
          fi

          # Commit changes
          git commit -m "$COMMIT_MSG" || {
            echo "‚ùå Commit failed"
            exit 1
          }

          echo "‚úÖ Changes committed successfully"

      - name: Push feature branch
        run: |
          echo "üöÄ Pushing feature branch to origin..."
          git push origin "${{ github.event.inputs.branch_name }}" || {
            echo "‚ùå Push failed"
            exit 1
          }
          echo "‚úÖ Feature branch pushed successfully"

      - name: Create deployment preview (if applicable)
        run: |
          echo "üåê Creating deployment preview..."

          # Check if this is a web project that can be deployed
          if [ -f "package.json" ] && (grep -q '"build"' package.json || grep -q '"dev"' package.json); then
            echo "üì¶ Web project detected, attempting preview deployment..."
            
            # Build the project with runtime environment variables
            if grep -q '"build"' package.json; then
              echo "üîê Re-exporting secrets for build step..."
              if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
                eval $(echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""')
                echo "‚úÖ Secrets re-exported for build step"
              fi
              
              echo "üîß Sourcing runtime environment variables before build..."
              source ./runtime_env_setup.sh
              
              npm run build && {
                echo "PREVIEW_BUILD_SUCCESS=true" >> $GITHUB_ENV
                echo "‚úÖ Build successful"
              } || {
                echo "‚ö†Ô∏è Build failed, skipping preview deployment"
                echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
              }
            else
              echo "‚ÑπÔ∏è No build script found, skipping preview"
              echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è Not a web project, skipping preview deployment"
            echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Detect build output directory
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          echo "üìÅ Detecting build output directory..."

          # Check for custom build directory from secret first
          if [ -n "${{ secrets.CUSTOM_BUILD_DIR }}" ]; then
            CUSTOM_DIR="${{ secrets.CUSTOM_BUILD_DIR }}"
            if [ -d "$CUSTOM_DIR" ] && [ "$(ls -A $CUSTOM_DIR 2>/dev/null)" ]; then
              BUILD_DIR="$CUSTOM_DIR"
              echo "BUILD_DIR=$CUSTOM_DIR" >> $GITHUB_ENV
              echo "‚úÖ Using custom build directory: $CUSTOM_DIR"
              ls -la "$CUSTOM_DIR"
              exit 0
            else
              echo "‚ö†Ô∏è Custom build directory '$CUSTOM_DIR' not found or empty, falling back to auto-detection"
            fi
          fi

          # Auto-detect common build output directories
          BUILD_DIRS=("dist" "build" "_site" "out" ".next" "public")

          for dir in "${BUILD_DIRS[@]}"; do
            if [ -d "$dir" ] && [ "$(ls -A $dir 2>/dev/null)" ]; then
              BUILD_DIR="$dir"
              echo "BUILD_DIR=$dir" >> $GITHUB_ENV
              echo "‚úÖ Build output directory found: $dir"
              break
            fi
          done

          # If no build directory found, use current directory for static sites
          if [ -z "${BUILD_DIR:-}" ]; then
            if [ -f "index.html" ]; then
              BUILD_DIR="."
              echo "BUILD_DIR=." >> $GITHUB_ENV
              echo "‚úÖ Using current directory for static site"
            else
              echo "‚ùå No build output directory found"
              echo "Available directories:"
              ls -la
              exit 1
            fi
          fi

          # List contents of chosen build directory
          echo "üìÑ Build directory contents:"
          ls -la "${BUILD_DIR}"

      - name: Deploy to Netlify (if build succeeded)
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          echo "üöÄ Installing and using Netlify CLI directly..."
          npm install -g netlify-cli@17.10.1

          # Deploy and capture output
          netlify deploy --dir=${{ env.BUILD_DIR }} --json > deploy_output.json

          # Extract URLs from output
          cat deploy_output.json
          DEPLOY_URL=$(cat deploy_output.json | grep -o '"deploy_url":"[^"]*' | cut -d'"' -f4)

          if [ -n "$DEPLOY_URL" ]; then
            echo "NETLIFY_URL=$DEPLOY_URL" >> $GITHUB_ENV
            echo "‚úÖ Deployed to: $DEPLOY_URL"
          else
            echo "‚ö†Ô∏è Could not extract deployment URL"
            cat deploy_output.json
          fi
        env:
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}

      - name: Extract Netlify deployment URL
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          # Extract preview URL from environment variable set in previous step
          DEPLOY_URL="$NETLIFY_URL"

          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Preview deployed: $DEPLOY_URL"
            echo "PREVIEW_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è No deployment URL received from Netlify"
            echo "Checking for deploy_output.json..."
            if [ -f "deploy_output.json" ]; then
              echo "Deploy output contents:"
              cat deploy_output.json

              # Try alternative JSON parsing methods
              DEPLOY_URL=$(cat deploy_output.json | jq -r '.deploy_url // empty' 2>/dev/null || echo "")
              if [ -z "$DEPLOY_URL" ]; then
                DEPLOY_URL=$(cat deploy_output.json | grep -o 'https://[^"]*\.netlify\.app' | head -1 || echo "")
              fi

              if [ -n "$DEPLOY_URL" ]; then
                echo "‚úÖ Extracted URL: $DEPLOY_URL"
                echo "PREVIEW_URL=$DEPLOY_URL" >> $GITHUB_ENV
              else
                echo "‚ùå Could not extract URL from deploy output"
              fi
            else
              echo "‚ùå deploy_output.json not found"
            fi
          fi

      - name: Setup Browserbase for screenshot generation
        if: env.PREVIEW_URL != ''
        run: |
          echo "üì∏ Setting up Browserbase for screenshot generation..."
          echo "‚úÖ Browserbase ready - using cloud browser infrastructure"

      - name: Generate screenshot and upload to CDN
        if: env.PREVIEW_URL != ''
        run: |
          echo "üì∏ Generating screenshot of deployed site with Browserbase..."

          # Wait for deployment to be ready
          sleep 5

          # Create screenshot script using Browserbase
          cat > screenshot.js << 'EOF'
          import { chromium } from 'playwright-core';
          import FormData from 'form-data';
          import fetch from 'node-fetch';
          import fs from 'fs';

          // Browserbase SDK (inline for simplicity)
          class Browserbase {
            constructor(options) {
              this.apiKey = options.apiKey;
              this.baseUrl = 'https://api.browserbase.com/v1';
            }

            async createSession(options) {
              const response = await fetch(`${this.baseUrl}/sessions`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-bb-api-key': this.apiKey,
                },
                body: JSON.stringify({
                  projectId: options.projectId,
                }),
              });
              return await response.json();
            }
          }

          (async () => {
            console.log('üöÄ Creating Browserbase session...');

            if (!process.env.BROWSERBASE_API_KEY) {
              console.error('‚ùå BROWSERBASE_API_KEY not found');
              process.exit(1);
            }

            if (!process.env.BROWSERBASE_PROJECT_ID) {
              console.error('‚ùå BROWSERBASE_PROJECT_ID not found');
              process.exit(1);
            }

            const bb = new Browserbase({
              apiKey: process.env.BROWSERBASE_API_KEY
            });

            const session = await bb.createSession({
              projectId: process.env.BROWSERBASE_PROJECT_ID,
            });

            if (!session.connectUrl) {
              console.error('‚ùå Failed to create Browserbase session:', session);
              process.exit(1);
            }

            console.log('‚úÖ Browserbase session created, connecting...');

            // Connect to remote browser
            const browser = await chromium.connectOverCDP(session.connectUrl);
            const defaultContext = browser.contexts()[0];
            const page = defaultContext.pages()[0];

            console.log('üìÑ Navigating to:', process.env.PREVIEW_URL);
            await page.goto(process.env.PREVIEW_URL, {
              waitUntil: 'domcontentloaded',
              timeout: 20000
            });

            // Wait for page to stabilize
            await page.waitForTimeout(2000);

            console.log('üì∏ Capturing screenshot with CDP...');

            // Use CDP for faster, more reliable screenshots
            const client = await defaultContext.newCDPSession(page);
            const { data } = await client.send('Page.captureScreenshot', {
              format: 'jpeg',
              quality: 90,
              captureBeyondViewport: true,
            });

            const screenshot = Buffer.from(data, 'base64');

            await browser.close();
            console.log('‚úÖ Screenshot captured successfully');

            // Upload to Uploadcare
            console.log('‚òÅÔ∏è Uploading to Uploadcare CDN...');

            const form = new FormData();
            form.append('UPLOADCARE_PUB_KEY', process.env.UPLOADCARE_PUBLIC_KEY);
            form.append('file', screenshot, {
              filename: 'screenshot.jpg',
              contentType: 'image/jpeg'
            });

            const response = await fetch('https://upload.uploadcare.com/base/', {
              method: 'POST',
              body: form
            });

            const result = await response.json();
            if (result.file) {
              const cdnUrl = `https://ucarecdn.com/${result.file}/`;
              console.log('‚úÖ Screenshot uploaded:', cdnUrl);
              console.log(`SCREENSHOT_URL=${cdnUrl}`);

              // Set environment variable for next steps
              fs.appendFileSync(process.env.GITHUB_ENV, `SCREENSHOT_URL=${cdnUrl}\n`);
            } else {
              console.error('‚ùå Upload failed:', result);
              process.exit(1);
            }
          })();
          EOF

          # Install required packages (much lighter without full Playwright)
          npm install playwright-core form-data node-fetch@2

          # Run screenshot script
          node screenshot.js || {
            echo "‚ö†Ô∏è Screenshot generation failed, but deployment was successful"
            echo "SCREENSHOT_URL=" >> $GITHUB_ENV
          }
        env:
          UPLOADCARE_PUBLIC_KEY: ${{ secrets.UPLOADCARE_PUBLIC_KEY }}
          BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
          BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}

      - name: Update commit with preview info
        if: env.PREVIEW_URL != ''
        run: |
          echo "üìù Adding preview info to commit..."

          # Amend commit with preview information
          UPDATED_COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ü§ñ Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}
          Preview: ${{ env.PREVIEW_URL }}

          ---PREVIEW-INFO---
          Preview URL: ${{ env.PREVIEW_URL }}
          Screenshot URL: ${{ env.SCREENSHOT_URL }}
          "

          git commit --amend -m "$UPDATED_COMMIT_MSG"
          git push origin "${{ github.event.inputs.branch_name }}" --force-with-lease

      - name: Create workspace node update payload
        run: |
          echo "üèóÔ∏è Creating workspace node update payload..."

          # Get commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)

          # Create payload for VGit workspace node creation
          cat > workspace_node_payload.json << EOF
          {
            "repository_full_name": "${{ github.repository }}",
            "branch_name": "${{ github.event.inputs.branch_name }}",
            "commit_sha": "$COMMIT_SHA",
            "username": "${{ github.event.inputs.username }}",
            "current_node": "${{ github.event.inputs.current_node }}",
            "preview_url": "${{ env.PREVIEW_URL }}",
            "screenshot_url": "${{ env.SCREENSHOT_URL }}",
            "workflow_run_id": "${{ github.run_id }}",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
          }
          EOF

          echo "‚úÖ Workspace node payload created"

      - name: Upload workspace payload as artifact
        uses: actions/upload-artifact@v4
        with:
          name: workspace-node-payload
          path: workspace_node_payload.json
          retention-days: 7

      - name: Summary
        run: |
          echo "üéâ Feature creation completed successfully!"
          echo ""
          echo "üìã Summary:"
          echo "- Branch: ${{ github.event.inputs.branch_name }}"
          echo "- Feature: ${{ github.event.inputs.request }}"
          echo "- Repository: ${{ github.repository }}"
          echo "- Commit SHA: $(git rev-parse HEAD)"
          if [ -n "${{ env.PREVIEW_URL }}" ]; then
            echo "- Preview URL: ${{ env.PREVIEW_URL }}"
          fi
          if [ -n "${{ env.SCREENSHOT_URL }}" ]; then
            echo "- Screenshot URL: ${{ env.SCREENSHOT_URL }}"
          fi
          echo "- Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
