name: VGit Create Feature
on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: "Name for the new branch"
        required: true
        type: string
      request:
        description: "Feature request description"
        required: true
        type: string
      username:
        description: "GitHub username"
        required: true
        type: string
      current_node:
        description: "Current workspace node (optional)"
        required: false
        type: string
      base_branch:
        description: "Base branch to create feature from"
        required: false
        type: string
        default: "main"
      environment:
        description: "GitHub environment to use for deployment"
        required: false
        type: string
      runtime_vars:
        description: "Comma-separated list of env var names to expose at runtime"
        required: false
        type: string
        default: ""

jobs:
  create-feature:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ github.event.inputs.environment || '' }}
    permissions:
      contents: write # For git operations (checkout, commit, push)
      actions: read # For workflow operations

    steps:
      - name: Validate inputs
        run: |
          if [ -z "${{ github.event.inputs.branch_name }}" ]; then
            echo "‚ùå Branch name is required"
            exit 1
          fi
          if [ -z "${{ github.event.inputs.request }}" ]; then
            echo "‚ùå Feature request is required"
            exit 1
          fi
          echo "‚úÖ Inputs validated"
          echo "Branch: ${{ github.event.inputs.branch_name }}"
          echo "Request: ${{ github.event.inputs.request }}"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config --global user.name "${{ github.event.inputs.username }}"
          git config --global user.email "${{ github.event.inputs.username }}@users.noreply.github.com"

      - name: Create feature branch
        run: |
          echo "üåø Creating feature branch: ${{ github.event.inputs.branch_name }}"

          # Ensure we're on the base branch
          git checkout ${{ github.event.inputs.base_branch }}
          git pull origin ${{ github.event.inputs.base_branch }}

          # Create and switch to feature branch
          git checkout -b "${{ github.event.inputs.branch_name }}"

          echo "‚úÖ Feature branch created successfully"
      - name: Update commit with pending preview info
        run: |
          echo "üìù Starting feature request"

          # Amend commit with preview information
          UPDATED_COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ü§ñ Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          ---PREVIEW-INFO---
          Preview URL: still_pending
          Screenshot URL: still_pending
          "

          git commit --amend -m "$UPDATED_COMMIT_MSG"
          git push origin "${{ github.event.inputs.branch_name }}" --force-with-lease
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: |
          if [ -f "package.json" ]; then
            echo "üì¶ Installing dependencies..."
            npm install
          else
            echo "‚ö†Ô∏è No package.json found, skipping dependency installation"
          fi

      - name: Export all secrets as environment variables dynamically
        run: |
          echo "üîê Dynamically exporting all secrets as environment variables..."
          if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
            echo "üìã Processing secrets from environment..."
            echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' >> $GITHUB_ENV
            echo "‚úÖ All secrets exported as environment variables"
          else
            echo "‚ÑπÔ∏è No secrets found in environment"
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Prepare runtime environment variables
        run: |
          echo "üîß Preparing runtime environment variables..."

          # Debug: Show which environment variables are available (names only, not values)
          echo "üîç Available environment variables (for debugging):"
          env | grep -E '^(ANTHROPIC|SUBSCRIBE|OPENAI|CUSTOM)' | cut -d'=' -f1 | sort || echo "No addon-related environment variables found"

          # Parse runtime_vars input (comma-separated list)
          RUNTIME_VARS="${{ github.event.inputs.runtime_vars }}"

          if [ -n "$RUNTIME_VARS" ] && [ "$RUNTIME_VARS" != "" ]; then
            echo "üìã Runtime variables to expose: $RUNTIME_VARS"
            
            # Create a script to export VITE_ prefixed versions
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "# Auto-generated runtime environment variables" >> runtime_env_setup.sh
            
            # Split comma-separated values and create VITE_ versions
            IFS=',' read -ra VARS <<< "$RUNTIME_VARS"
            for var in "${VARS[@]}"; do
              # Trim whitespace
              var=$(echo "$var" | xargs)
              
              if [ -n "$var" ]; then
                # Convert to uppercase
                upper_var=$(echo "$var" | tr '[:lower:]' '[:upper:]')
                vite_var="VITE_$upper_var"
                
                echo "Creating runtime variable: $upper_var -> $vite_var"
                
                # Add export statement to script
                echo "if [ -n \"\${$upper_var}\" ]; then" >> runtime_env_setup.sh
                echo "  export $vite_var=\"\${$upper_var}\"" >> runtime_env_setup.sh
                echo "  echo \"‚úÖ Exposed $upper_var as $vite_var\"" >> runtime_env_setup.sh
                echo "else" >> runtime_env_setup.sh
                echo "  echo \"‚ö†Ô∏è $upper_var not found in environment\"" >> runtime_env_setup.sh
                echo "fi" >> runtime_env_setup.sh
              fi
            done
            
            # Make the script executable
            chmod +x runtime_env_setup.sh
            
            echo "üîç Runtime environment setup script created:"
            cat runtime_env_setup.sh
          else
            echo "‚ÑπÔ∏è No runtime variables specified, skipping VITE_ prefix setup"
            echo "#!/bin/bash" > runtime_env_setup.sh
            echo "echo 'No runtime variables to expose'" >> runtime_env_setup.sh
            chmod +x runtime_env_setup.sh
          fi

      - name: Install Claude Agent SDK
        run: |
          echo "üì¶ Installing Claude Agent SDK and dependencies..."
          npm install @anthropic-ai/claude-agent-sdk
          npm install -g tsx  # TypeScript executor
          echo "‚úÖ Claude Agent SDK installed"

      - name: Check for CLAUDE.md
        run: |
          echo "üìÑ Checking for CLAUDE.md project instructions..."
          if [ -f "CLAUDE.md" ]; then
            echo "‚úÖ Found CLAUDE.md - Claude Code will use project-specific instructions"
            wc -l CLAUDE.md | awk '{print "  Lines:", $1}'
          else
            echo "‚ÑπÔ∏è No CLAUDE.md found - using generic instructions"
          fi

      - name: Implement feature with Claude Agent SDK
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "ü§ñ Running Claude Agent SDK to implement feature..."

          # Create prompt file
          cat > feature_prompt.txt << 'PROMPT_EOF'
          Please implement the following feature request:

          **Feature Request:** ${{ github.event.inputs.request }}

          **Project Context:**
          - Repository: ${{ github.repository }}
          - Branch: ${{ github.event.inputs.branch_name }}
          - Base Branch: ${{ github.event.inputs.base_branch }}
          - Requested by: ${{ github.event.inputs.username }}

          **CRITICAL - Read Project Instructions First:**
          1. Check if there is a CLAUDE.md file in the repository root
          2. If CLAUDE.md exists, READ IT FIRST and follow ALL guidelines specified there
          3. The CLAUDE.md file contains critical project-specific instructions, architecture details, and conventions
          4. All implementation decisions should follow the patterns and guidelines in CLAUDE.md

          **Implementation Steps:**
          1. Read CLAUDE.md if it exists (this is mandatory!)
          2. Analyze the existing codebase structure and patterns (check existing components, styling approach, state management)
          3. Implement the feature following the project's conventions from CLAUDE.md
          4. If you need to add dependencies, update package.json accordingly
          5. Ensure the code compiles and follows best practices
          6. Make minimal, focused changes that accomplish the feature request

          **Frontend/UI Implementation Best Practices:**
          When implementing UI features, pages, or components:

          - **Layout & Spacing:**
            - Use fullscreen layouts when appropriate (min-h-screen, w-full, h-full)
            - Implement proper responsive design with mobile-first approach
            - Use consistent spacing (padding, margin) following the project's design system
            - Utilize flexbox/grid for layouts (flex, grid, gap utilities)

          - **Styling & Visual Design:**
            - Follow the existing styling approach (CSS Modules, Tailwind, styled-components, etc.)
            - Maintain consistent color palette and theming from existing components
            - Add smooth transitions and hover states for interactive elements
            - Ensure proper contrast ratios for accessibility (WCAG AA minimum)
            - Use semantic color names (primary, secondary, accent, etc.)

          - **Component Architecture:**
            - Create reusable, composable components
            - Separate presentation from business logic
            - Use TypeScript interfaces for all component props
            - Implement proper loading states, error boundaries, and empty states
            - Follow existing file structure and naming conventions

          - **User Experience:**
            - Add loading spinners or skeletons for async operations
            - Implement proper error handling with user-friendly messages
            - Provide visual feedback for user actions (button states, form validation)
            - Ensure keyboard navigation and focus management
            - Add appropriate aria-labels for accessibility

          - **Modern UI Patterns:**
            - Use CSS Grid/Flexbox for complex layouts
            - Implement proper z-index layering for modals, dropdowns, tooltips
            - Add smooth animations (transform, opacity) not layout shifts
            - Use CSS variables for theming support
            - Implement dark mode support if the project has it

          - **Performance:**
            - Lazy load components when appropriate
            - Optimize images (proper formats, sizes, lazy loading)
            - Avoid unnecessary re-renders (useMemo, useCallback, React.memo)
            - Use code splitting for large features

          **Important Quality Checks:**
          - CLAUDE.md is your primary source of truth for this project
          - Always assume environment variables are available, and never leave situations where env vars are needed as mocked or TODO or placeholders. Environment variables are always there.
          - Ensure all changes are production-ready and fully functional
          - Test edge cases and error scenarios
          - Verify responsive behavior across screen sizes
          - Do not make unnecessary changes outside the feature scope
          - Match the quality and style of existing components

          **CRITICAL - Subscribe.dev Usage Policy:**
          - ONLY use subscribe.dev when EXPLICITLY requested in the feature request
          - Explicit requests include phrases like:
            * "with subscribe.dev"
            * "using subscribe.dev"
            * "integrate subscribe.dev"
            * "add subscribe.dev"
          - If subscribe.dev is NOT explicitly mentioned, DO NOT add or use it
          - Default to standard implementations without subscribe.dev unless specifically asked

          Start by reading CLAUDE.md (if present), then implement the feature with professional-grade UI/UX.
          PROMPT_EOF

          # Run Claude Agent SDK with the prompt
          # Captures all logs to claude-agent.log for later analysis
          tsx .github/scripts/run-claude-agent.ts feature_prompt.txt || {
            echo "‚ö†Ô∏è Claude Agent SDK execution had issues, checking for changes..."
            CLAUDE_FAILED=true
          }

          echo "‚úÖ Claude Agent SDK execution completed"

          # Check if execution failed and save status
          if [ "$CLAUDE_FAILED" = "true" ]; then
            echo "CLAUDE_EXECUTION_FAILED=true" >> $GITHUB_ENV
          fi

      - name: Upload Claude Agent logs as artifact
        if: always()  # Upload logs even if previous step failed
        uses: actions/upload-artifact@v4
        with:
          name: claude-agent-logs
          path: |
            claude-agent.log
            claude-agent.log.json
            claude-error-summary.txt
          retention-days: 7
          if-no-files-found: warn

      - name: Install new dependencies (if package.json changed)
        run: |
          cat package.json

          if git diff --name-only | grep -q "package.json"; then
            echo "üì¶ package.json was modified, installing new dependencies..."
            npm install
          else
            echo "‚ÑπÔ∏è No package.json changes detected"
          fi

      - name: Verify changes
        run: |
          echo "üîç Verifying implemented changes..."

          # Check if any files were modified
          if git diff --quiet; then
            echo "‚ö†Ô∏è No changes detected. Creating a minimal change to complete the workflow."
            echo "# Feature: ${{ github.event.inputs.request }}" >> FEATURE_LOG.md
            echo "- Implemented on: $(date)" >> FEATURE_LOG.md
            echo "- Branch: ${{ github.event.inputs.branch_name }}" >> FEATURE_LOG.md
            echo "" >> FEATURE_LOG.md
          else
            echo "‚úÖ Changes detected:"
            git diff --name-only
          fi

      - name: Run tests (if available)
        run: |
          echo "üß™ Running tests..."
          if [ -f "package.json" ] && grep -q '"test"' package.json; then
            npm test || {
              echo "‚ö†Ô∏è Tests failed, but continuing with feature implementation"
              echo "TEST_FAILURES=true" >> $GITHUB_ENV
            }
          else
            echo "‚ÑπÔ∏è No test script found, skipping tests"
          fi

      - name: Commit changes
        run: |
          echo "üìù Committing changes..."

          # Add all changes
          git add .

          # Check if Claude execution failed and include error logs
          if [ "$CLAUDE_EXECUTION_FAILED" = "true" ] && [ -f "claude-error-summary.txt" ]; then
            echo "‚ö†Ô∏è Claude execution failed, including error logs in commit message"

            # Read error summary (truncated to 500 chars)
            ERROR_SUMMARY=$(cat claude-error-summary.txt)

            COMMIT_MSG="feat: ${{ github.event.inputs.request }} [FAILED]

          ‚ùå Claude Agent SDK execution failed

          ü§ñ Generated with VGit AI (Claude Agent SDK)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          ---ERROR-LOG---
          ${ERROR_SUMMARY}

          Full logs available in GitHub Actions artifacts.

          Co-Authored-By: Claude Code <ai@vgit.app>"
          else
            # Standard commit message for successful execution
            COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ü§ñ Generated with VGit AI (Claude Agent SDK)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}

          Co-Authored-By: Claude Code <ai@vgit.app>"
          fi

          # Commit changes
          git commit -m "$COMMIT_MSG" || {
            echo "‚ùå Commit failed"
            exit 1
          }

          echo "‚úÖ Changes committed successfully"

      - name: Push feature branch
        run: |
          echo "üöÄ Pushing feature branch to origin..."
          git push origin "${{ github.event.inputs.branch_name }}" || {
            echo "‚ùå Push failed"
            exit 1
          }
          echo "‚úÖ Feature branch pushed successfully"

      - name: Create deployment preview (if applicable)
        run: |
          echo "üåê Creating deployment preview..."

          # Check if this is a web project that can be deployed
          if [ -f "package.json" ] && (grep -q '"build"' package.json || grep -q '"dev"' package.json); then
            echo "üì¶ Web project detected, attempting preview deployment..."
            
            # Build the project with runtime environment variables
            if grep -q '"build"' package.json; then
              echo "üîê Re-exporting secrets for build step..."
              if [ "$SECRETS_JSON" != "null" ] && [ "$SECRETS_JSON" != "" ]; then
                eval $(echo "$SECRETS_JSON" | jq -r 'to_entries | .[] | "export \(.key)=\"\(.value)\""')
                echo "‚úÖ Secrets re-exported for build step"
              fi
              
              echo "üîß Sourcing runtime environment variables before build..."
              source ./runtime_env_setup.sh
              
              npm run build && {
                echo "PREVIEW_BUILD_SUCCESS=true" >> $GITHUB_ENV
                echo "‚úÖ Build successful"
              } || {
                echo "‚ö†Ô∏è Build failed, skipping preview deployment"
                echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
              }
            else
              echo "‚ÑπÔ∏è No build script found, skipping preview"
              echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
            fi
          else
            echo "‚ÑπÔ∏è Not a web project, skipping preview deployment"
            echo "PREVIEW_BUILD_SUCCESS=false" >> $GITHUB_ENV
          fi
        env:
          SECRETS_JSON: ${{ toJson(secrets) }}

      - name: Detect build output directory
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          echo "üìÅ Detecting build output directory..."

          # Check for custom build directory from secret first
          if [ -n "${{ secrets.CUSTOM_BUILD_DIR }}" ]; then
            CUSTOM_DIR="${{ secrets.CUSTOM_BUILD_DIR }}"
            if [ -d "$CUSTOM_DIR" ] && [ "$(ls -A $CUSTOM_DIR 2>/dev/null)" ]; then
              BUILD_DIR="$CUSTOM_DIR"
              echo "BUILD_DIR=$CUSTOM_DIR" >> $GITHUB_ENV
              echo "‚úÖ Using custom build directory: $CUSTOM_DIR"
              ls -la "$CUSTOM_DIR"
              exit 0
            else
              echo "‚ö†Ô∏è Custom build directory '$CUSTOM_DIR' not found or empty, falling back to auto-detection"
            fi
          fi

          # Auto-detect common build output directories
          BUILD_DIRS=("dist" "build" "_site" "out" ".next" "public")

          for dir in "${BUILD_DIRS[@]}"; do
            if [ -d "$dir" ] && [ "$(ls -A $dir 2>/dev/null)" ]; then
              BUILD_DIR="$dir"
              echo "BUILD_DIR=$dir" >> $GITHUB_ENV
              echo "‚úÖ Build output directory found: $dir"
              break
            fi
          done

          # If no build directory found, use current directory for static sites
          if [ -z "${BUILD_DIR:-}" ]; then
            if [ -f "index.html" ]; then
              BUILD_DIR="."
              echo "BUILD_DIR=." >> $GITHUB_ENV
              echo "‚úÖ Using current directory for static site"
            else
              echo "‚ùå No build output directory found"
              echo "Available directories:"
              ls -la
              exit 1
            fi
          fi

          # List contents of chosen build directory
          echo "üìÑ Build directory contents:"
          ls -la "${BUILD_DIR}"

      - name: Deploy to Netlify (if build succeeded)
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          echo "üöÄ Installing and using Netlify CLI directly..."
          npm install -g netlify-cli@17.10.1

          # Deploy and capture output
          netlify deploy --dir=${{ env.BUILD_DIR }} --json > deploy_output.json

          # Extract URLs from output
          cat deploy_output.json
          DEPLOY_URL=$(cat deploy_output.json | grep -o '"deploy_url":"[^"]*' | cut -d'"' -f4)

          if [ -n "$DEPLOY_URL" ]; then
            echo "NETLIFY_URL=$DEPLOY_URL" >> $GITHUB_ENV
            echo "‚úÖ Deployed to: $DEPLOY_URL"
          else
            echo "‚ö†Ô∏è Could not extract deployment URL"
            cat deploy_output.json
          fi
        env:
          NETLIFY_SITE_ID: ${{ secrets.NETLIFY_SITE_ID }}
          NETLIFY_AUTH_TOKEN: ${{ secrets.NETLIFY_AUTH_TOKEN }}

      - name: Extract Netlify deployment URL
        if: env.PREVIEW_BUILD_SUCCESS == 'true'
        run: |
          # Extract preview URL from environment variable set in previous step
          DEPLOY_URL="$NETLIFY_URL"

          if [ -n "$DEPLOY_URL" ]; then
            echo "‚úÖ Preview deployed: $DEPLOY_URL"
            echo "PREVIEW_URL=$DEPLOY_URL" >> $GITHUB_ENV
          else
            echo "‚ö†Ô∏è No deployment URL received from Netlify"
            echo "Checking for deploy_output.json..."
            if [ -f "deploy_output.json" ]; then
              echo "Deploy output contents:"
              cat deploy_output.json

              # Try alternative JSON parsing methods
              DEPLOY_URL=$(cat deploy_output.json | jq -r '.deploy_url // empty' 2>/dev/null || echo "")
              if [ -z "$DEPLOY_URL" ]; then
                DEPLOY_URL=$(cat deploy_output.json | grep -o 'https://[^"]*\.netlify\.app' | head -1 || echo "")
              fi

              if [ -n "$DEPLOY_URL" ]; then
                echo "‚úÖ Extracted URL: $DEPLOY_URL"
                echo "PREVIEW_URL=$DEPLOY_URL" >> $GITHUB_ENV
              else
                echo "‚ùå Could not extract URL from deploy output"
              fi
            else
              echo "‚ùå deploy_output.json not found"
            fi
          fi

      - name: Setup Browserbase for screenshot generation
        if: env.PREVIEW_URL != ''
        run: |
          echo "üì∏ Setting up Browserbase for screenshot generation..."
          echo "‚úÖ Browserbase ready - using cloud browser infrastructure"

      - name: Generate screenshot and upload to CDN
        if: env.PREVIEW_URL != ''
        run: |
          echo "üì∏ Generating screenshot of deployed site with Browserbase..."

          # Wait for deployment to be ready
          sleep 5

          # Create screenshot script using Browserbase
          cat > screenshot.js << 'EOF'
          import { chromium } from 'playwright-core';
          import FormData from 'form-data';
          import fetch from 'node-fetch';
          import fs from 'fs';

          // Browserbase SDK (inline for simplicity)
          class Browserbase {
            constructor(options) {
              this.apiKey = options.apiKey;
              this.baseUrl = 'https://api.browserbase.com/v1';
            }

            async createSession(options) {
              const response = await fetch(`${this.baseUrl}/sessions`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-bb-api-key': this.apiKey,
                },
                body: JSON.stringify({
                  projectId: options.projectId,
                }),
              });
              return await response.json();
            }
          }

          (async () => {
            console.log('üöÄ Creating Browserbase session...');

            if (!process.env.BROWSERBASE_API_KEY) {
              console.error('‚ùå BROWSERBASE_API_KEY not found');
              process.exit(1);
            }

            if (!process.env.BROWSERBASE_PROJECT_ID) {
              console.error('‚ùå BROWSERBASE_PROJECT_ID not found');
              process.exit(1);
            }

            const bb = new Browserbase({
              apiKey: process.env.BROWSERBASE_API_KEY
            });

            const session = await bb.createSession({
              projectId: process.env.BROWSERBASE_PROJECT_ID,
            });

            if (!session.connectUrl) {
              console.error('‚ùå Failed to create Browserbase session:', session);
              process.exit(1);
            }

            console.log('‚úÖ Browserbase session created, connecting...');

            // Connect to remote browser
            const browser = await chromium.connectOverCDP(session.connectUrl);
            const defaultContext = browser.contexts()[0];
            const page = defaultContext.pages()[0];

            console.log('üìÑ Navigating to:', process.env.PREVIEW_URL);
            await page.goto(process.env.PREVIEW_URL, {
              waitUntil: 'domcontentloaded',
              timeout: 20000
            });

            // Wait for page to stabilize
            await page.waitForTimeout(2000);

            console.log('üì∏ Capturing screenshot with CDP...');

            // Use CDP for faster, more reliable screenshots
            const client = await defaultContext.newCDPSession(page);
            const { data } = await client.send('Page.captureScreenshot', {
              format: 'jpeg',
              quality: 90,
              captureBeyondViewport: true,
            });

            const screenshot = Buffer.from(data, 'base64');

            await browser.close();
            console.log('‚úÖ Screenshot captured successfully');

            // Upload to Uploadcare
            console.log('‚òÅÔ∏è Uploading to Uploadcare CDN...');

            const form = new FormData();
            form.append('UPLOADCARE_PUB_KEY', process.env.UPLOADCARE_PUBLIC_KEY);
            form.append('file', screenshot, {
              filename: 'screenshot.jpg',
              contentType: 'image/jpeg'
            });

            const response = await fetch('https://upload.uploadcare.com/base/', {
              method: 'POST',
              body: form
            });

            const result = await response.json();
            if (result.file) {
              const cdnUrl = `https://ucarecdn.com/${result.file}/`;
              console.log('‚úÖ Screenshot uploaded:', cdnUrl);
              console.log(`SCREENSHOT_URL=${cdnUrl}`);

              // Set environment variable for next steps
              fs.appendFileSync(process.env.GITHUB_ENV, `SCREENSHOT_URL=${cdnUrl}\n`);
            } else {
              console.error('‚ùå Upload failed:', result);
              process.exit(1);
            }
          })();
          EOF

          # Install required packages (much lighter without full Playwright)
          npm install playwright-core form-data node-fetch@2

          # Run screenshot script
          node screenshot.js || {
            echo "‚ö†Ô∏è Screenshot generation failed, but deployment was successful"
            echo "SCREENSHOT_URL=" >> $GITHUB_ENV
          }
        env:
          UPLOADCARE_PUBLIC_KEY: ${{ secrets.UPLOADCARE_PUBLIC_KEY }}
          BROWSERBASE_API_KEY: ${{ secrets.BROWSERBASE_API_KEY }}
          BROWSERBASE_PROJECT_ID: ${{ secrets.BROWSERBASE_PROJECT_ID }}

      - name: Update commit with preview info
        if: env.PREVIEW_URL != ''
        run: |
          echo "üìù Adding preview info to commit..."

          # Amend commit with preview information
          UPDATED_COMMIT_MSG="feat: ${{ github.event.inputs.request }}

          ü§ñ Generated with VGit AI (Claude Code)

          Branch: ${{ github.event.inputs.branch_name }}
          Requested by: ${{ github.event.inputs.username }}
          Preview: ${{ env.PREVIEW_URL }}

          ---PREVIEW-INFO---
          Preview URL: ${{ env.PREVIEW_URL }}
          Screenshot URL: ${{ env.SCREENSHOT_URL }}
          "

          git commit --amend -m "$UPDATED_COMMIT_MSG"
          git push origin "${{ github.event.inputs.branch_name }}" --force-with-lease

      - name: Create workspace node update payload
        run: |
          echo "üèóÔ∏è Creating workspace node update payload..."

          # Get commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)

          # Create payload for VGit workspace node creation
          cat > workspace_node_payload.json << EOF
          {
            "repository_full_name": "${{ github.repository }}",
            "branch_name": "${{ github.event.inputs.branch_name }}",
            "commit_sha": "$COMMIT_SHA",
            "username": "${{ github.event.inputs.username }}",
            "current_node": "${{ github.event.inputs.current_node }}",
            "preview_url": "${{ env.PREVIEW_URL }}",
            "screenshot_url": "${{ env.SCREENSHOT_URL }}",
            "workflow_run_id": "${{ github.run_id }}",
            "created_at": "$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)"
          }
          EOF

          echo "‚úÖ Workspace node payload created"

      - name: Upload workspace payload as artifact
        uses: actions/upload-artifact@v4
        with:
          name: workspace-node-payload
          path: workspace_node_payload.json
          retention-days: 7

      - name: Summary
        run: |
          echo "üéâ Feature creation completed successfully!"
          echo ""
          echo "üìã Summary:"
          echo "- Branch: ${{ github.event.inputs.branch_name }}"
          echo "- Feature: ${{ github.event.inputs.request }}"
          echo "- Repository: ${{ github.repository }}"
          echo "- Commit SHA: $(git rev-parse HEAD)"
          if [ -n "${{ env.PREVIEW_URL }}" ]; then
            echo "- Preview URL: ${{ env.PREVIEW_URL }}"
          fi
          if [ -n "${{ env.SCREENSHOT_URL }}" ]; then
            echo "- Screenshot URL: ${{ env.SCREENSHOT_URL }}"
          fi
          echo "- Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
